// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package dbpg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    first_name,
    middle_name,
    surname,
    username,
    login_email,
    primary_email_id,
    password_hash
) VALUES ($1, $2, $3, $4, $5, $6, $7)
    RETURNING id, first_name, middle_name, surname, username, login_email, primary_email_id, sign_up_stage, password_hash, enabled, sysop, created_on, updated_at
`

type CreateUserParams struct {
	FirstName      string
	MiddleName     pgtype.Text
	Surname        pgtype.Text
	Username       string
	LoginEmail     string
	PrimaryEmailID int64
	PasswordHash   string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.FirstName,
		arg.MiddleName,
		arg.Surname,
		arg.Username,
		arg.LoginEmail,
		arg.PrimaryEmailID,
		arg.PasswordHash,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.MiddleName,
		&i.Surname,
		&i.Username,
		&i.LoginEmail,
		&i.PrimaryEmailID,
		&i.SignUpStage,
		&i.PasswordHash,
		&i.Enabled,
		&i.Sysop,
		&i.CreatedOn,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserEmail = `-- name: CreateUserEmail :one
INSERT INTO user_emails (
    user_id,
    email,
    enabled,
    is_verified
    ) VALUES ($1, $2, $3, $4)
    RETURNING id, user_id, email, is_verified, enabled, created_on, updated_at
`

type CreateUserEmailParams struct {
	UserID     int64
	Email      string
	Enabled    bool
	IsVerified bool
}

// First create the email, then create the user in separate operations
func (q *Queries) CreateUserEmail(ctx context.Context, arg CreateUserEmailParams) (UserEmail, error) {
	row := q.db.QueryRow(ctx, createUserEmail,
		arg.UserID,
		arg.Email,
		arg.Enabled,
		arg.IsVerified,
	)
	var i UserEmail
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.IsVerified,
		&i.Enabled,
		&i.CreatedOn,
		&i.UpdatedAt,
	)
	return i, err
}

const emailExists = `-- name: EmailExists :one
SELECT
    EXISTS(select 1 from users where users.login_email = $1)
`

type EmailExistsParams struct {
	LoginEmail string
}

func (q *Queries) EmailExists(ctx context.Context, arg EmailExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, emailExists, arg.LoginEmail)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, first_name, middle_name, surname, username, login_email, primary_email_id, sign_up_stage, password_hash, enabled, sysop, created_on, updated_at FROM users WHERE login_email = $1
`

type GetUserByEmailParams struct {
	LoginEmail string
}

func (q *Queries) GetUserByEmail(ctx context.Context, arg GetUserByEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, arg.LoginEmail)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.MiddleName,
		&i.Surname,
		&i.Username,
		&i.LoginEmail,
		&i.PrimaryEmailID,
		&i.SignUpStage,
		&i.PasswordHash,
		&i.Enabled,
		&i.Sysop,
		&i.CreatedOn,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, first_name, middle_name, surname, username, login_email, primary_email_id, sign_up_stage, password_hash, enabled, sysop, created_on, updated_at FROM users WHERE id = $1
`

type GetUserByIdParams struct {
	ID int64
}

func (q *Queries) GetUserById(ctx context.Context, arg GetUserByIdParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.MiddleName,
		&i.Surname,
		&i.Username,
		&i.LoginEmail,
		&i.PrimaryEmailID,
		&i.SignUpStage,
		&i.PasswordHash,
		&i.Enabled,
		&i.Sysop,
		&i.CreatedOn,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, first_name, middle_name, surname, username, login_email, primary_email_id, sign_up_stage, password_hash, enabled, sysop, created_on, updated_at FROM users WHERE username = $1
`

type GetUserByUsernameParams struct {
	Username string
}

func (q *Queries) GetUserByUsername(ctx context.Context, arg GetUserByUsernameParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, arg.Username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.MiddleName,
		&i.Surname,
		&i.Username,
		&i.LoginEmail,
		&i.PrimaryEmailID,
		&i.SignUpStage,
		&i.PasswordHash,
		&i.Enabled,
		&i.Sysop,
		&i.CreatedOn,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
    first_name = $2,
    middle_name = $3,
    surname = $4,
    updated_at = NOW()
WHERE id = $1
    RETURNING id, first_name, middle_name, surname, username, login_email, primary_email_id, sign_up_stage, password_hash, enabled, sysop, created_on, updated_at
`

type UpdateUserParams struct {
	ID         int64
	FirstName  string
	MiddleName pgtype.Text
	Surname    pgtype.Text
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.FirstName,
		arg.MiddleName,
		arg.Surname,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.MiddleName,
		&i.Surname,
		&i.Username,
		&i.LoginEmail,
		&i.PrimaryEmailID,
		&i.SignUpStage,
		&i.PasswordHash,
		&i.Enabled,
		&i.Sysop,
		&i.CreatedOn,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserEnabled = `-- name: UpdateUserEnabled :one
UPDATE users
SET enabled = $2,
    updated_at = NOW()
WHERE id = $1
    RETURNING id, first_name, middle_name, surname, username, login_email, primary_email_id, sign_up_stage, password_hash, enabled, sysop, created_on, updated_at
`

type UpdateUserEnabledParams struct {
	ID      int64
	Enabled bool
}

func (q *Queries) UpdateUserEnabled(ctx context.Context, arg UpdateUserEnabledParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserEnabled, arg.ID, arg.Enabled)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.MiddleName,
		&i.Surname,
		&i.Username,
		&i.LoginEmail,
		&i.PrimaryEmailID,
		&i.SignUpStage,
		&i.PasswordHash,
		&i.Enabled,
		&i.Sysop,
		&i.CreatedOn,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
set password_hash = $2
where id = $1
`

type UpdateUserPasswordParams struct {
	ID           int64
	PasswordHash string
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}

const updateUserSignUpStage = `-- name: UpdateUserSignUpStage :one
UPDATE users
SET sign_up_stage = $2,
    updated_at = NOW()
WHERE id = $1
    RETURNING id, first_name, middle_name, surname, username, login_email, primary_email_id, sign_up_stage, password_hash, enabled, sysop, created_on, updated_at
`

type UpdateUserSignUpStageParams struct {
	ID          int64
	SignUpStage pgtype.Int4
}

func (q *Queries) UpdateUserSignUpStage(ctx context.Context, arg UpdateUserSignUpStageParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserSignUpStage, arg.ID, arg.SignUpStage)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.MiddleName,
		&i.Surname,
		&i.Username,
		&i.LoginEmail,
		&i.PrimaryEmailID,
		&i.SignUpStage,
		&i.PasswordHash,
		&i.Enabled,
		&i.Sysop,
		&i.CreatedOn,
		&i.UpdatedAt,
	)
	return i, err
}

const userExists = `-- name: UserExists :one
SELECT
    EXISTS(SELECT 1 FROM users WHERE users.login_email = $1) AS email_exists,
    EXISTS(SELECT 1 FROM users WHERE users.username = $2) AS username_exists
`

type UserExistsParams struct {
	LoginEmail string
	Username   string
}

type UserExistsRow struct {
	EmailExists    bool
	UsernameExists bool
}

func (q *Queries) UserExists(ctx context.Context, arg UserExistsParams) (UserExistsRow, error) {
	row := q.db.QueryRow(ctx, userExists, arg.LoginEmail, arg.Username)
	var i UserExistsRow
	err := row.Scan(&i.EmailExists, &i.UsernameExists)
	return i, err
}
