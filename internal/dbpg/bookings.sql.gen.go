// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bookings.sql

package dbpg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBooking = `-- name: CreateBooking :one
INSERT INTO bookings (
    customer_id, vehicle_id, scheduled_date, scheduled_time,
    estimated_duration_mins, status, payment_status,
    subtotal, deposit_amount, total_amount,
    stripe_payment_intent_id, stripe_deposit_intent_id, notes
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, customer_id, vehicle_id, scheduled_date, scheduled_time, estimated_duration_mins, status, payment_status, subtotal, deposit_amount, total_amount, stripe_payment_intent_id, stripe_deposit_intent_id, notes, created_at, updated_at
`

type CreateBookingParams struct {
	CustomerID            int64
	VehicleID             pgtype.Int8
	ScheduledDate         pgtype.Date
	ScheduledTime         pgtype.Time
	EstimatedDurationMins int32
	Status                BookingStatus
	PaymentStatus         PaymentStatus
	Subtotal              int64
	DepositAmount         int64
	TotalAmount           int64
	StripePaymentIntentID pgtype.Text
	StripeDepositIntentID pgtype.Text
	Notes                 pgtype.Text
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (Booking, error) {
	row := q.db.QueryRow(ctx, createBooking,
		arg.CustomerID,
		arg.VehicleID,
		arg.ScheduledDate,
		arg.ScheduledTime,
		arg.EstimatedDurationMins,
		arg.Status,
		arg.PaymentStatus,
		arg.Subtotal,
		arg.DepositAmount,
		arg.TotalAmount,
		arg.StripePaymentIntentID,
		arg.StripeDepositIntentID,
		arg.Notes,
	)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.VehicleID,
		&i.ScheduledDate,
		&i.ScheduledTime,
		&i.EstimatedDurationMins,
		&i.Status,
		&i.PaymentStatus,
		&i.Subtotal,
		&i.DepositAmount,
		&i.TotalAmount,
		&i.StripePaymentIntentID,
		&i.StripeDepositIntentID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createBookingService = `-- name: CreateBookingService :one
INSERT INTO booking_services (booking_id, service_id, price_at_booking)
VALUES ($1, $2, $3)
RETURNING id, booking_id, service_id, price_at_booking
`

type CreateBookingServiceParams struct {
	BookingID      int64
	ServiceID      int64
	PriceAtBooking int64
}

func (q *Queries) CreateBookingService(ctx context.Context, arg CreateBookingServiceParams) (BookingService, error) {
	row := q.db.QueryRow(ctx, createBookingService, arg.BookingID, arg.ServiceID, arg.PriceAtBooking)
	var i BookingService
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.ServiceID,
		&i.PriceAtBooking,
	)
	return i, err
}

const createBookingServiceOption = `-- name: CreateBookingServiceOption :one
INSERT INTO booking_service_options (booking_service_id, service_option_id, price_at_booking)
VALUES ($1, $2, $3)
RETURNING id, booking_service_id, service_option_id, price_at_booking
`

type CreateBookingServiceOptionParams struct {
	BookingServiceID int64
	ServiceOptionID  int64
	PriceAtBooking   int64
}

func (q *Queries) CreateBookingServiceOption(ctx context.Context, arg CreateBookingServiceOptionParams) (BookingServiceOption, error) {
	row := q.db.QueryRow(ctx, createBookingServiceOption, arg.BookingServiceID, arg.ServiceOptionID, arg.PriceAtBooking)
	var i BookingServiceOption
	err := row.Scan(
		&i.ID,
		&i.BookingServiceID,
		&i.ServiceOptionID,
		&i.PriceAtBooking,
	)
	return i, err
}

const getBookingByID = `-- name: GetBookingByID :one
SELECT b.id, b.customer_id, b.vehicle_id, b.scheduled_date, b.scheduled_time, b.estimated_duration_mins, b.status, b.payment_status, b.subtotal, b.deposit_amount, b.total_amount, b.stripe_payment_intent_id, b.stripe_deposit_intent_id, b.notes, b.created_at, b.updated_at,
       cp.user_id AS customer_user_id,
       cp.phone AS customer_phone,
       v.make AS vehicle_make,
       v.model AS vehicle_model,
       v.rego AS vehicle_rego
FROM bookings b
JOIN customer_profiles cp ON cp.id = b.customer_id
LEFT JOIN vehicles v ON v.id = b.vehicle_id
WHERE b.id = $1
`

type GetBookingByIDParams struct {
	ID int64
}

type GetBookingByIDRow struct {
	ID                    int64
	CustomerID            int64
	VehicleID             pgtype.Int8
	ScheduledDate         pgtype.Date
	ScheduledTime         pgtype.Time
	EstimatedDurationMins int32
	Status                BookingStatus
	PaymentStatus         PaymentStatus
	Subtotal              int64
	DepositAmount         int64
	TotalAmount           int64
	StripePaymentIntentID pgtype.Text
	StripeDepositIntentID pgtype.Text
	Notes                 pgtype.Text
	CreatedAt             pgtype.Timestamptz
	UpdatedAt             pgtype.Timestamptz
	CustomerUserID        int64
	CustomerPhone         pgtype.Text
	VehicleMake           pgtype.Text
	VehicleModel          pgtype.Text
	VehicleRego           pgtype.Text
}

func (q *Queries) GetBookingByID(ctx context.Context, arg GetBookingByIDParams) (GetBookingByIDRow, error) {
	row := q.db.QueryRow(ctx, getBookingByID, arg.ID)
	var i GetBookingByIDRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.VehicleID,
		&i.ScheduledDate,
		&i.ScheduledTime,
		&i.EstimatedDurationMins,
		&i.Status,
		&i.PaymentStatus,
		&i.Subtotal,
		&i.DepositAmount,
		&i.TotalAmount,
		&i.StripePaymentIntentID,
		&i.StripeDepositIntentID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerUserID,
		&i.CustomerPhone,
		&i.VehicleMake,
		&i.VehicleModel,
		&i.VehicleRego,
	)
	return i, err
}

const listBookingServiceOptions = `-- name: ListBookingServiceOptions :many
SELECT bso.id, bso.booking_service_id, bso.service_option_id,
       bso.price_at_booking,
       so.name AS option_name
FROM booking_service_options bso
JOIN service_options so ON so.id = bso.service_option_id
WHERE bso.booking_service_id = $1
`

type ListBookingServiceOptionsParams struct {
	BookingServiceID int64
}

type ListBookingServiceOptionsRow struct {
	ID               int64
	BookingServiceID int64
	ServiceOptionID  int64
	PriceAtBooking   int64
	OptionName       string
}

func (q *Queries) ListBookingServiceOptions(ctx context.Context, arg ListBookingServiceOptionsParams) ([]ListBookingServiceOptionsRow, error) {
	rows, err := q.db.Query(ctx, listBookingServiceOptions, arg.BookingServiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBookingServiceOptionsRow
	for rows.Next() {
		var i ListBookingServiceOptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.BookingServiceID,
			&i.ServiceOptionID,
			&i.PriceAtBooking,
			&i.OptionName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingServices = `-- name: ListBookingServices :many
SELECT bs.id, bs.booking_id, bs.service_id, bs.price_at_booking,
       s.name AS service_name, s.slug AS service_slug
FROM booking_services bs
JOIN services s ON s.id = bs.service_id
WHERE bs.booking_id = $1
`

type ListBookingServicesParams struct {
	BookingID int64
}

type ListBookingServicesRow struct {
	ID             int64
	BookingID      int64
	ServiceID      int64
	PriceAtBooking int64
	ServiceName    string
	ServiceSlug    string
}

func (q *Queries) ListBookingServices(ctx context.Context, arg ListBookingServicesParams) ([]ListBookingServicesRow, error) {
	rows, err := q.db.Query(ctx, listBookingServices, arg.BookingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBookingServicesRow
	for rows.Next() {
		var i ListBookingServicesRow
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.ServiceID,
			&i.PriceAtBooking,
			&i.ServiceName,
			&i.ServiceSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByCustomer = `-- name: ListBookingsByCustomer :many
SELECT id, customer_id, vehicle_id, scheduled_date, scheduled_time, estimated_duration_mins, status, payment_status, subtotal, deposit_amount, total_amount, stripe_payment_intent_id, stripe_deposit_intent_id, notes, created_at, updated_at FROM bookings
WHERE customer_id = $1
ORDER BY scheduled_date DESC, scheduled_time DESC
`

type ListBookingsByCustomerParams struct {
	CustomerID int64
}

func (q *Queries) ListBookingsByCustomer(ctx context.Context, arg ListBookingsByCustomerParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookingsByCustomer, arg.CustomerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.VehicleID,
			&i.ScheduledDate,
			&i.ScheduledTime,
			&i.EstimatedDurationMins,
			&i.Status,
			&i.PaymentStatus,
			&i.Subtotal,
			&i.DepositAmount,
			&i.TotalAmount,
			&i.StripePaymentIntentID,
			&i.StripeDepositIntentID,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByDateRange = `-- name: ListBookingsByDateRange :many
SELECT id, customer_id, vehicle_id, scheduled_date, scheduled_time, estimated_duration_mins, status, payment_status, subtotal, deposit_amount, total_amount, stripe_payment_intent_id, stripe_deposit_intent_id, notes, created_at, updated_at FROM bookings
WHERE scheduled_date >= $1 AND scheduled_date <= $2
ORDER BY scheduled_date, scheduled_time
`

type ListBookingsByDateRangeParams struct {
	ScheduledDate   pgtype.Date
	ScheduledDate_2 pgtype.Date
}

func (q *Queries) ListBookingsByDateRange(ctx context.Context, arg ListBookingsByDateRangeParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookingsByDateRange, arg.ScheduledDate, arg.ScheduledDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.VehicleID,
			&i.ScheduledDate,
			&i.ScheduledTime,
			&i.EstimatedDurationMins,
			&i.Status,
			&i.PaymentStatus,
			&i.Subtotal,
			&i.DepositAmount,
			&i.TotalAmount,
			&i.StripePaymentIntentID,
			&i.StripeDepositIntentID,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsForDate = `-- name: ListBookingsForDate :many
SELECT id, customer_id, vehicle_id, scheduled_date, scheduled_time, estimated_duration_mins, status, payment_status, subtotal, deposit_amount, total_amount, stripe_payment_intent_id, stripe_deposit_intent_id, notes, created_at, updated_at FROM bookings
WHERE scheduled_date = $1
  AND status NOT IN ('cancelled')
ORDER BY scheduled_time
`

type ListBookingsForDateParams struct {
	ScheduledDate pgtype.Date
}

func (q *Queries) ListBookingsForDate(ctx context.Context, arg ListBookingsForDateParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookingsForDate, arg.ScheduledDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.VehicleID,
			&i.ScheduledDate,
			&i.ScheduledTime,
			&i.EstimatedDurationMins,
			&i.Status,
			&i.PaymentStatus,
			&i.Subtotal,
			&i.DepositAmount,
			&i.TotalAmount,
			&i.StripePaymentIntentID,
			&i.StripeDepositIntentID,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookingPaymentStatus = `-- name: UpdateBookingPaymentStatus :one
UPDATE bookings
SET payment_status = $2
WHERE id = $1
RETURNING id, customer_id, vehicle_id, scheduled_date, scheduled_time, estimated_duration_mins, status, payment_status, subtotal, deposit_amount, total_amount, stripe_payment_intent_id, stripe_deposit_intent_id, notes, created_at, updated_at
`

type UpdateBookingPaymentStatusParams struct {
	ID            int64
	PaymentStatus PaymentStatus
}

func (q *Queries) UpdateBookingPaymentStatus(ctx context.Context, arg UpdateBookingPaymentStatusParams) (Booking, error) {
	row := q.db.QueryRow(ctx, updateBookingPaymentStatus, arg.ID, arg.PaymentStatus)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.VehicleID,
		&i.ScheduledDate,
		&i.ScheduledTime,
		&i.EstimatedDurationMins,
		&i.Status,
		&i.PaymentStatus,
		&i.Subtotal,
		&i.DepositAmount,
		&i.TotalAmount,
		&i.StripePaymentIntentID,
		&i.StripeDepositIntentID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBookingStatus = `-- name: UpdateBookingStatus :one
UPDATE bookings
SET status = $2
WHERE id = $1
RETURNING id, customer_id, vehicle_id, scheduled_date, scheduled_time, estimated_duration_mins, status, payment_status, subtotal, deposit_amount, total_amount, stripe_payment_intent_id, stripe_deposit_intent_id, notes, created_at, updated_at
`

type UpdateBookingStatusParams struct {
	ID     int64
	Status BookingStatus
}

func (q *Queries) UpdateBookingStatus(ctx context.Context, arg UpdateBookingStatusParams) (Booking, error) {
	row := q.db.QueryRow(ctx, updateBookingStatus, arg.ID, arg.Status)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.VehicleID,
		&i.ScheduledDate,
		&i.ScheduledTime,
		&i.EstimatedDurationMins,
		&i.Status,
		&i.PaymentStatus,
		&i.Subtotal,
		&i.DepositAmount,
		&i.TotalAmount,
		&i.StripePaymentIntentID,
		&i.StripeDepositIntentID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
