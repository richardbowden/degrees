// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: schedule.sql

package dbpg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBlackout = `-- name: CreateBlackout :one
INSERT INTO schedule_blackouts (date, reason)
VALUES ($1, $2)
RETURNING id, date, reason, created_at
`

type CreateBlackoutParams struct {
	Date   pgtype.Date
	Reason pgtype.Text
}

func (q *Queries) CreateBlackout(ctx context.Context, arg CreateBlackoutParams) (ScheduleBlackout, error) {
	row := q.db.QueryRow(ctx, createBlackout, arg.Date, arg.Reason)
	var i ScheduleBlackout
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const deleteBlackout = `-- name: DeleteBlackout :exec
DELETE FROM schedule_blackouts
WHERE id = $1
`

type DeleteBlackoutParams struct {
	ID int64
}

func (q *Queries) DeleteBlackout(ctx context.Context, arg DeleteBlackoutParams) error {
	_, err := q.db.Exec(ctx, deleteBlackout, arg.ID)
	return err
}

const getScheduleConfig = `-- name: GetScheduleConfig :many
SELECT id, day_of_week, open_time, close_time, is_open, buffer_minutes FROM schedule_config
ORDER BY day_of_week
`

func (q *Queries) GetScheduleConfig(ctx context.Context) ([]ScheduleConfig, error) {
	rows, err := q.db.Query(ctx, getScheduleConfig)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScheduleConfig
	for rows.Next() {
		var i ScheduleConfig
		if err := rows.Scan(
			&i.ID,
			&i.DayOfWeek,
			&i.OpenTime,
			&i.CloseTime,
			&i.IsOpen,
			&i.BufferMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleConfigForDay = `-- name: GetScheduleConfigForDay :one
SELECT id, day_of_week, open_time, close_time, is_open, buffer_minutes FROM schedule_config
WHERE day_of_week = $1
`

type GetScheduleConfigForDayParams struct {
	DayOfWeek int32
}

func (q *Queries) GetScheduleConfigForDay(ctx context.Context, arg GetScheduleConfigForDayParams) (ScheduleConfig, error) {
	row := q.db.QueryRow(ctx, getScheduleConfigForDay, arg.DayOfWeek)
	var i ScheduleConfig
	err := row.Scan(
		&i.ID,
		&i.DayOfWeek,
		&i.OpenTime,
		&i.CloseTime,
		&i.IsOpen,
		&i.BufferMinutes,
	)
	return i, err
}

const isDateBlackedOut = `-- name: IsDateBlackedOut :one
SELECT EXISTS(
    SELECT 1 FROM schedule_blackouts WHERE date = $1
) AS is_blacked_out
`

type IsDateBlackedOutParams struct {
	Date pgtype.Date
}

func (q *Queries) IsDateBlackedOut(ctx context.Context, arg IsDateBlackedOutParams) (bool, error) {
	row := q.db.QueryRow(ctx, isDateBlackedOut, arg.Date)
	var is_blacked_out bool
	err := row.Scan(&is_blacked_out)
	return is_blacked_out, err
}

const listBlackoutDates = `-- name: ListBlackoutDates :many
SELECT id, date, reason, created_at FROM schedule_blackouts
ORDER BY date
`

func (q *Queries) ListBlackoutDates(ctx context.Context) ([]ScheduleBlackout, error) {
	rows, err := q.db.Query(ctx, listBlackoutDates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScheduleBlackout
	for rows.Next() {
		var i ScheduleBlackout
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScheduleConfig = `-- name: UpdateScheduleConfig :one
INSERT INTO schedule_config (day_of_week, open_time, close_time, is_open, buffer_minutes)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (day_of_week)
DO UPDATE SET open_time = EXCLUDED.open_time,
              close_time = EXCLUDED.close_time,
              is_open = EXCLUDED.is_open,
              buffer_minutes = EXCLUDED.buffer_minutes
RETURNING id, day_of_week, open_time, close_time, is_open, buffer_minutes
`

type UpdateScheduleConfigParams struct {
	DayOfWeek     int32
	OpenTime      pgtype.Time
	CloseTime     pgtype.Time
	IsOpen        bool
	BufferMinutes int32
}

func (q *Queries) UpdateScheduleConfig(ctx context.Context, arg UpdateScheduleConfigParams) (ScheduleConfig, error) {
	row := q.db.QueryRow(ctx, updateScheduleConfig,
		arg.DayOfWeek,
		arg.OpenTime,
		arg.CloseTime,
		arg.IsOpen,
		arg.BufferMinutes,
	)
	var i ScheduleConfig
	err := row.Scan(
		&i.ID,
		&i.DayOfWeek,
		&i.OpenTime,
		&i.CloseTime,
		&i.IsOpen,
		&i.BufferMinutes,
	)
	return i, err
}
