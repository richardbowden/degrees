// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: customers.sql

package dbpg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCustomerProfile = `-- name: CreateCustomerProfile :one
INSERT INTO customer_profiles (user_id, phone, address, suburb, postcode, notes)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, phone, address, suburb, postcode, notes, created_at, updated_at
`

type CreateCustomerProfileParams struct {
	UserID   int64
	Phone    pgtype.Text
	Address  pgtype.Text
	Suburb   pgtype.Text
	Postcode pgtype.Text
	Notes    pgtype.Text
}

func (q *Queries) CreateCustomerProfile(ctx context.Context, arg CreateCustomerProfileParams) (CustomerProfile, error) {
	row := q.db.QueryRow(ctx, createCustomerProfile,
		arg.UserID,
		arg.Phone,
		arg.Address,
		arg.Suburb,
		arg.Postcode,
		arg.Notes,
	)
	var i CustomerProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Phone,
		&i.Address,
		&i.Suburb,
		&i.Postcode,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVehicle = `-- name: CreateVehicle :one
INSERT INTO vehicles (
    customer_id, make, model, year, colour, rego,
    paint_type, condition_notes, is_primary, vehicle_category_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, customer_id, make, model, year, colour, rego, paint_type, condition_notes, is_primary, created_at, updated_at, vehicle_category_id
`

type CreateVehicleParams struct {
	CustomerID        int64
	Make              string
	Model             string
	Year              pgtype.Int4
	Colour            pgtype.Text
	Rego              pgtype.Text
	PaintType         pgtype.Text
	ConditionNotes    pgtype.Text
	IsPrimary         bool
	VehicleCategoryID pgtype.Int8
}

func (q *Queries) CreateVehicle(ctx context.Context, arg CreateVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, createVehicle,
		arg.CustomerID,
		arg.Make,
		arg.Model,
		arg.Year,
		arg.Colour,
		arg.Rego,
		arg.PaintType,
		arg.ConditionNotes,
		arg.IsPrimary,
		arg.VehicleCategoryID,
	)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Make,
		&i.Model,
		&i.Year,
		&i.Colour,
		&i.Rego,
		&i.PaintType,
		&i.ConditionNotes,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.VehicleCategoryID,
	)
	return i, err
}

const deleteVehicle = `-- name: DeleteVehicle :exec
DELETE FROM vehicles
WHERE id = $1
`

type DeleteVehicleParams struct {
	ID int64
}

func (q *Queries) DeleteVehicle(ctx context.Context, arg DeleteVehicleParams) error {
	_, err := q.db.Exec(ctx, deleteVehicle, arg.ID)
	return err
}

const getCustomerProfileByUserID = `-- name: GetCustomerProfileByUserID :one
SELECT id, user_id, phone, address, suburb, postcode, notes, created_at, updated_at FROM customer_profiles
WHERE user_id = $1
`

type GetCustomerProfileByUserIDParams struct {
	UserID int64
}

func (q *Queries) GetCustomerProfileByUserID(ctx context.Context, arg GetCustomerProfileByUserIDParams) (CustomerProfile, error) {
	row := q.db.QueryRow(ctx, getCustomerProfileByUserID, arg.UserID)
	var i CustomerProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Phone,
		&i.Address,
		&i.Suburb,
		&i.Postcode,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVehicleByID = `-- name: GetVehicleByID :one
SELECT id, customer_id, make, model, year, colour, rego, paint_type, condition_notes, is_primary, created_at, updated_at, vehicle_category_id FROM vehicles
WHERE id = $1
`

type GetVehicleByIDParams struct {
	ID int64
}

func (q *Queries) GetVehicleByID(ctx context.Context, arg GetVehicleByIDParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicleByID, arg.ID)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Make,
		&i.Model,
		&i.Year,
		&i.Colour,
		&i.Rego,
		&i.PaintType,
		&i.ConditionNotes,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.VehicleCategoryID,
	)
	return i, err
}

const listCustomers = `-- name: ListCustomers :many
SELECT id, user_id, phone, address, suburb, postcode, notes, created_at, updated_at FROM customer_profiles
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListCustomersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListCustomers(ctx context.Context, arg ListCustomersParams) ([]CustomerProfile, error) {
	rows, err := q.db.Query(ctx, listCustomers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomerProfile
	for rows.Next() {
		var i CustomerProfile
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Phone,
			&i.Address,
			&i.Suburb,
			&i.Postcode,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVehiclesByCustomer = `-- name: ListVehiclesByCustomer :many
SELECT id, customer_id, make, model, year, colour, rego, paint_type, condition_notes, is_primary, created_at, updated_at, vehicle_category_id FROM vehicles
WHERE customer_id = $1
ORDER BY is_primary DESC, created_at DESC
`

type ListVehiclesByCustomerParams struct {
	CustomerID int64
}

func (q *Queries) ListVehiclesByCustomer(ctx context.Context, arg ListVehiclesByCustomerParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, listVehiclesByCustomer, arg.CustomerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Make,
			&i.Model,
			&i.Year,
			&i.Colour,
			&i.Rego,
			&i.PaintType,
			&i.ConditionNotes,
			&i.IsPrimary,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.VehicleCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomerProfile = `-- name: UpdateCustomerProfile :one
UPDATE customer_profiles
SET phone = $2, address = $3, suburb = $4, postcode = $5, notes = $6
WHERE id = $1
RETURNING id, user_id, phone, address, suburb, postcode, notes, created_at, updated_at
`

type UpdateCustomerProfileParams struct {
	ID       int64
	Phone    pgtype.Text
	Address  pgtype.Text
	Suburb   pgtype.Text
	Postcode pgtype.Text
	Notes    pgtype.Text
}

func (q *Queries) UpdateCustomerProfile(ctx context.Context, arg UpdateCustomerProfileParams) (CustomerProfile, error) {
	row := q.db.QueryRow(ctx, updateCustomerProfile,
		arg.ID,
		arg.Phone,
		arg.Address,
		arg.Suburb,
		arg.Postcode,
		arg.Notes,
	)
	var i CustomerProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Phone,
		&i.Address,
		&i.Suburb,
		&i.Postcode,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateVehicle = `-- name: UpdateVehicle :one
UPDATE vehicles
SET make = $2, model = $3, year = $4, colour = $5, rego = $6,
    paint_type = $7, condition_notes = $8, is_primary = $9,
    vehicle_category_id = $10
WHERE id = $1
RETURNING id, customer_id, make, model, year, colour, rego, paint_type, condition_notes, is_primary, created_at, updated_at, vehicle_category_id
`

type UpdateVehicleParams struct {
	ID                int64
	Make              string
	Model             string
	Year              pgtype.Int4
	Colour            pgtype.Text
	Rego              pgtype.Text
	PaintType         pgtype.Text
	ConditionNotes    pgtype.Text
	IsPrimary         bool
	VehicleCategoryID pgtype.Int8
}

func (q *Queries) UpdateVehicle(ctx context.Context, arg UpdateVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, updateVehicle,
		arg.ID,
		arg.Make,
		arg.Model,
		arg.Year,
		arg.Colour,
		arg.Rego,
		arg.PaintType,
		arg.ConditionNotes,
		arg.IsPrimary,
		arg.VehicleCategoryID,
	)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Make,
		&i.Model,
		&i.Year,
		&i.Colour,
		&i.Rego,
		&i.PaintType,
		&i.ConditionNotes,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.VehicleCategoryID,
	)
	return i, err
}
