// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: settings_v2.sql

package dbpg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteSetting = `-- name: DeleteSetting :exec
DELETE FROM settings WHERE id = $1
`

type DeleteSettingParams struct {
	ID int64
}

// Delete a specific setting by ID
func (q *Queries) DeleteSetting(ctx context.Context, arg DeleteSettingParams) error {
	_, err := q.db.Exec(ctx, deleteSetting, arg.ID)
	return err
}

const getSettingByID = `-- name: GetSettingByID :one
SELECT
    id,
    scope,
    organization_id,
    project_id,
    user_id,
    subsystem,
    key,
    value,
    description,
    created_at,
    updated_at,
    updated_by
FROM settings
WHERE id = $1
`

type GetSettingByIDParams struct {
	ID int64
}

// Get a specific setting by ID
func (q *Queries) GetSettingByID(ctx context.Context, arg GetSettingByIDParams) (Setting, error) {
	row := q.db.QueryRow(ctx, getSettingByID, arg.ID)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.Scope,
		&i.OrganizationID,
		&i.ProjectID,
		&i.UserID,
		&i.Subsystem,
		&i.Key,
		&i.Value,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getSettingHierarchy = `-- name: GetSettingHierarchy :many
SELECT
    id,
    scope,
    organization_id,
    project_id,
    user_id,
    subsystem,
    key,
    value,
    description,
    created_at,
    updated_at,
    updated_by
FROM settings
WHERE subsystem = $1
    AND key = $2
    AND (
        scope = 'system'
        OR (scope = 'organization' AND organization_id = $3)
        OR (scope = 'project' AND project_id = $4)
        OR (scope = 'user' AND user_id = $5)
    )
ORDER BY
    CASE scope
        WHEN 'user' THEN 4
        WHEN 'project' THEN 3
        WHEN 'organization' THEN 2
        WHEN 'system' THEN 1
    END DESC
LIMIT 1
`

type GetSettingHierarchyParams struct {
	Subsystem      string
	Key            string
	OrganizationID pgtype.Int8
	ProjectID      pgtype.Int8
	UserID         pgtype.Int8
}

// Get all matching settings in hierarchy order (system → org → project → user)
// Returns ordered by precedence (higher scope overrides lower)
func (q *Queries) GetSettingHierarchy(ctx context.Context, arg GetSettingHierarchyParams) ([]Setting, error) {
	rows, err := q.db.Query(ctx, getSettingHierarchy,
		arg.Subsystem,
		arg.Key,
		arg.OrganizationID,
		arg.ProjectID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Setting
	for rows.Next() {
		var i Setting
		if err := rows.Scan(
			&i.ID,
			&i.Scope,
			&i.OrganizationID,
			&i.ProjectID,
			&i.UserID,
			&i.Subsystem,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSettingsBySubsystem = `-- name: GetSettingsBySubsystem :many
SELECT
    id,
    scope,
    organization_id,
    project_id,
    user_id,
    subsystem,
    key,
    value,
    description,
    created_at,
    updated_at,
    updated_by
FROM settings
WHERE subsystem = $1
    AND (
        scope = 'system'
        OR (scope = 'organization' AND organization_id = $2)
        OR (scope = 'project' AND project_id = $3)
        OR (scope = 'user' AND user_id = $4)
    )
ORDER BY
    key,
    CASE scope
        WHEN 'user' THEN 4
        WHEN 'project' THEN 3
        WHEN 'organization' THEN 2
        WHEN 'system' THEN 1
    END DESC
`

type GetSettingsBySubsystemParams struct {
	Subsystem      string
	OrganizationID pgtype.Int8
	ProjectID      pgtype.Int8
	UserID         pgtype.Int8
}

// Get all settings for a subsystem with hierarchy resolution
func (q *Queries) GetSettingsBySubsystem(ctx context.Context, arg GetSettingsBySubsystemParams) ([]Setting, error) {
	rows, err := q.db.Query(ctx, getSettingsBySubsystem,
		arg.Subsystem,
		arg.OrganizationID,
		arg.ProjectID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Setting
	for rows.Next() {
		var i Setting
		if err := rows.Scan(
			&i.ID,
			&i.Scope,
			&i.OrganizationID,
			&i.ProjectID,
			&i.UserID,
			&i.Subsystem,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllSettings = `-- name: ListAllSettings :many
SELECT
    id,
    scope,
    organization_id,
    project_id,
    user_id,
    subsystem,
    key,
    value,
    description,
    created_at,
    updated_at,
    updated_by
FROM settings
ORDER BY subsystem, key, scope
`

// List all settings (for admin interface)
func (q *Queries) ListAllSettings(ctx context.Context) ([]Setting, error) {
	rows, err := q.db.Query(ctx, listAllSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Setting
	for rows.Next() {
		var i Setting
		if err := rows.Scan(
			&i.ID,
			&i.Scope,
			&i.OrganizationID,
			&i.ProjectID,
			&i.UserID,
			&i.Subsystem,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationSettings = `-- name: ListOrganizationSettings :many
SELECT
    id,
    scope,
    organization_id,
    project_id,
    user_id,
    subsystem,
    key,
    value,
    description,
    created_at,
    updated_at,
    updated_by
FROM settings
WHERE scope = 'system'
    OR (scope = 'organization' AND organization_id = $1)
ORDER BY subsystem, key, scope DESC
`

type ListOrganizationSettingsParams struct {
	OrganizationID pgtype.Int8
}

// List settings for a specific organization (including system defaults)
func (q *Queries) ListOrganizationSettings(ctx context.Context, arg ListOrganizationSettingsParams) ([]Setting, error) {
	rows, err := q.db.Query(ctx, listOrganizationSettings, arg.OrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Setting
	for rows.Next() {
		var i Setting
		if err := rows.Scan(
			&i.ID,
			&i.Scope,
			&i.OrganizationID,
			&i.ProjectID,
			&i.UserID,
			&i.Subsystem,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectSettings = `-- name: ListProjectSettings :many
SELECT
    id,
    scope,
    organization_id,
    project_id,
    user_id,
    subsystem,
    key,
    value,
    description,
    created_at,
    updated_at,
    updated_by
FROM settings
WHERE scope = 'system'
    OR (scope = 'organization' AND organization_id = $1)
    OR (scope = 'project' AND project_id = $2)
ORDER BY subsystem, key, scope DESC
`

type ListProjectSettingsParams struct {
	OrganizationID pgtype.Int8
	ProjectID      pgtype.Int8
}

// List settings for a specific project (including org and system defaults)
// Note: Pass both project_id and org_id as parameters
func (q *Queries) ListProjectSettings(ctx context.Context, arg ListProjectSettingsParams) ([]Setting, error) {
	rows, err := q.db.Query(ctx, listProjectSettings, arg.OrganizationID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Setting
	for rows.Next() {
		var i Setting
		if err := rows.Scan(
			&i.ID,
			&i.Scope,
			&i.OrganizationID,
			&i.ProjectID,
			&i.UserID,
			&i.Subsystem,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSystemSettings = `-- name: ListSystemSettings :many
SELECT
    id,
    scope,
    organization_id,
    project_id,
    user_id,
    subsystem,
    key,
    value,
    description,
    created_at,
    updated_at,
    updated_by
FROM settings
WHERE scope = 'system'
ORDER BY subsystem, key
`

// List all system-level settings
func (q *Queries) ListSystemSettings(ctx context.Context) ([]Setting, error) {
	rows, err := q.db.Query(ctx, listSystemSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Setting
	for rows.Next() {
		var i Setting
		if err := rows.Scan(
			&i.ID,
			&i.Scope,
			&i.OrganizationID,
			&i.ProjectID,
			&i.UserID,
			&i.Subsystem,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertOrganizationSetting = `-- name: UpsertOrganizationSetting :one
INSERT INTO settings (scope, organization_id, subsystem, key, value, description, updated_by)
VALUES ('organization', $1, $2, $3, $4, $5, $6)
ON CONFLICT (scope, COALESCE(organization_id, 0), COALESCE(project_id, 0), COALESCE(user_id, 0), subsystem, key)
DO UPDATE SET
    value = EXCLUDED.value,
    description = COALESCE(EXCLUDED.description, settings.description),
    updated_by = EXCLUDED.updated_by,
    updated_at = NOW()
RETURNING id, scope, organization_id, project_id, user_id, subsystem, key, value, description, created_at, updated_at, updated_by
`

type UpsertOrganizationSettingParams struct {
	OrganizationID pgtype.Int8
	Subsystem      string
	Key            string
	Value          []byte
	Description    pgtype.Text
	UpdatedBy      pgtype.Int8
}

// Create or update an organization-level setting
func (q *Queries) UpsertOrganizationSetting(ctx context.Context, arg UpsertOrganizationSettingParams) (Setting, error) {
	row := q.db.QueryRow(ctx, upsertOrganizationSetting,
		arg.OrganizationID,
		arg.Subsystem,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.UpdatedBy,
	)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.Scope,
		&i.OrganizationID,
		&i.ProjectID,
		&i.UserID,
		&i.Subsystem,
		&i.Key,
		&i.Value,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const upsertProjectSetting = `-- name: UpsertProjectSetting :one
INSERT INTO settings (scope, project_id, subsystem, key, value, description, updated_by)
VALUES ('project', $1, $2, $3, $4, $5, $6)
ON CONFLICT (scope, COALESCE(organization_id, 0), COALESCE(project_id, 0), COALESCE(user_id, 0), subsystem, key)
DO UPDATE SET
    value = EXCLUDED.value,
    description = COALESCE(EXCLUDED.description, settings.description),
    updated_by = EXCLUDED.updated_by,
    updated_at = NOW()
RETURNING id, scope, organization_id, project_id, user_id, subsystem, key, value, description, created_at, updated_at, updated_by
`

type UpsertProjectSettingParams struct {
	ProjectID   pgtype.Int8
	Subsystem   string
	Key         string
	Value       []byte
	Description pgtype.Text
	UpdatedBy   pgtype.Int8
}

// Create or update a project-level setting
func (q *Queries) UpsertProjectSetting(ctx context.Context, arg UpsertProjectSettingParams) (Setting, error) {
	row := q.db.QueryRow(ctx, upsertProjectSetting,
		arg.ProjectID,
		arg.Subsystem,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.UpdatedBy,
	)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.Scope,
		&i.OrganizationID,
		&i.ProjectID,
		&i.UserID,
		&i.Subsystem,
		&i.Key,
		&i.Value,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const upsertSystemSetting = `-- name: UpsertSystemSetting :one
INSERT INTO settings (scope, subsystem, key, value, description, updated_by)
VALUES ('system', $1, $2, $3, $4, $5)
ON CONFLICT (scope, COALESCE(organization_id, 0), COALESCE(project_id, 0), COALESCE(user_id, 0), subsystem, key)
DO UPDATE SET
    value = EXCLUDED.value,
    description = COALESCE(EXCLUDED.description, settings.description),
    updated_by = EXCLUDED.updated_by,
    updated_at = NOW()
RETURNING id, scope, organization_id, project_id, user_id, subsystem, key, value, description, created_at, updated_at, updated_by
`

type UpsertSystemSettingParams struct {
	Subsystem   string
	Key         string
	Value       []byte
	Description pgtype.Text
	UpdatedBy   pgtype.Int8
}

// Create or update a system-level setting
func (q *Queries) UpsertSystemSetting(ctx context.Context, arg UpsertSystemSettingParams) (Setting, error) {
	row := q.db.QueryRow(ctx, upsertSystemSetting,
		arg.Subsystem,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.UpdatedBy,
	)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.Scope,
		&i.OrganizationID,
		&i.ProjectID,
		&i.UserID,
		&i.Subsystem,
		&i.Key,
		&i.Value,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const upsertUserSetting = `-- name: UpsertUserSetting :one
INSERT INTO settings (scope, user_id, subsystem, key, value, description, updated_by)
VALUES ('user', $1, $2, $3, $4, $5, $6)
ON CONFLICT (scope, COALESCE(organization_id, 0), COALESCE(project_id, 0), COALESCE(user_id, 0), subsystem, key)
DO UPDATE SET
    value = EXCLUDED.value,
    description = COALESCE(EXCLUDED.description, settings.description),
    updated_by = EXCLUDED.updated_by,
    updated_at = NOW()
RETURNING id, scope, organization_id, project_id, user_id, subsystem, key, value, description, created_at, updated_at, updated_by
`

type UpsertUserSettingParams struct {
	UserID      pgtype.Int8
	Subsystem   string
	Key         string
	Value       []byte
	Description pgtype.Text
	UpdatedBy   pgtype.Int8
}

// Create or update a user-level setting
func (q *Queries) UpsertUserSetting(ctx context.Context, arg UpsertUserSettingParams) (Setting, error) {
	row := q.db.QueryRow(ctx, upsertUserSetting,
		arg.UserID,
		arg.Subsystem,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.UpdatedBy,
	)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.Scope,
		&i.OrganizationID,
		&i.ProjectID,
		&i.UserID,
		&i.Subsystem,
		&i.Key,
		&i.Value,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}
